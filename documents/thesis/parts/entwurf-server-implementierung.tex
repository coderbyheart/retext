\subsection{Implementierung des Anwendungsservers}

Für den Prototypen wurden das PHP-Framework \trademark{Symfony2}\footnote{\url{http://symfony.com/}} eingesetzt, das von sich aus bereits viele Anforderungen aus dem vorangegangenen Abschnitt erfüllt. Da im Kern jeder Web-Anwendung HTTP-Anfragen beantwortet werden, überträgt \trademark{Symfony2} dieses Paradigma auf die Art und Weise, wie im Framework Anfragen verarbeitet werden: mit Hilfe einer Routen-Konfiguration werden Controller für auf bestimmt Pfade in der Anfrage-URL registriert und vom Framework automatisch instanziert und aufgerufen. Die Controller schreiben dann ihre Antwort in ein Antwort-Objekt, das vom Framework als Antwort gesendet wird. Oberstes Prinzip bei der Entwicklung des Frameworks war die Modularisierung und die Wiederverwendbarkeit, so dass alle Komponenten nur mit Hilfe eines Service-Containers kommunizieren. Dadurch sind \trademark{Symfony2} besonders leicht zu warten und auch zu testen, entsprechende Unit-Testing-Komponenten werden bereits mitgeliefert.

\subsubsection{Klassendiagramm}

\begin{center}
\includegraphics[width=\textwidth]{media/prototyp-klassendiagramm.pdf}
\end{center}
\captionof{figure}{Klassendiagramm des Prototypen}\label{chart:prototyp-klassendiagramm}

\bigskip

Abbildung \ref{chart:prototyp-klassendiagramm} zeigt das Klassendiagramm der Implementierung des Prototypen.

\subsubsection{API}

Alle Funktionen des Anwendungsservers sind über eine Schnittstelle verwendbar, die JSON-Objekte enthalten dabei Zusatzinformationen zum Kontext und zu Relationen, wie in Abschnitt \ref{l:anbindung-gui} / S.\pageref{l:anbindung-gui} beschrieben. 

\begin{samepage}
\begin{verbatim}
{
    "@context":"http://jsonld.retext.it/Container",
    "@subject":"/api/container/4fdf26e7820b905118000001",
    "@relations":[
        {
            "@context":"http://coderbyheart.de/jsonld/Relation",
            "relatedcontext":"http://jsonld.retext.it/Project",
            "href":"/api/project/4fdf26e7820b905118000000",
            "list":false
        },
        {
            "@context":"http://coderbyheart.de/jsonld/Relation",
            "relatedcontext":"http://jsonld.retext.it/Element",
            "role":"http://jsonld.retext.it/ontology/child",
            "href":"/api/element?parent=4fdf26e7820b905118000001",
            "list":true
        },
        …
    ],
    "id": "4fdf26e7820b905118000001",
    "name": "Abschnitt 1",
    …
}
\end{verbatim}

Diese Listing zeigt als Beispiel das JSON-Objekt eines Containers. In der \texttt{@relations}-Liste ist der Verweis auf das Eltern-Element enthalten, aber auch auf die Liste mit untergeordneten Elementen dieses Containers. Im Client werden die Relationen je nach Bedarf durchsucht und die passende ausgewählt, sofern weitere Daten benötigt werden. Die jeweilige URL ist in \texttt{href} enthalten, so dass sich im Quellcode des Clients nur wenige hart-kodierte Endpunkte finden.
\end{samepage}

\subsubsection{Persistenz}

\begin{center}
\includegraphics[width=0.65\textwidth]{media/prototyp-persistenz.pdf}
\end{center}
\captionof{figure}{Persistierte Objekte im Prototypen}\label{chart:prototype-persistenz}

\bigskip

Zum Persistieren der Daten kommt \trademark{MongoDB}\footnote{\url{http://www.mongodb.org/}}, eine No-SQL-Datenbank zum Einsatz, diese ermöglicht das unkomplizierte speichern auch komplexer Dokumentenstrukturen. Die Wahl einer nicht-relationen Datenbank bietet den Vorteil, dass aufwändiges Zusammensetzen und Zerlegen von Dokumenten entfallen kann. In der Datenbank werden die in Abbildung \ref{chart:prototype-persistenz} gezeigten Domänenobjekte gespeichert. Das Laden- und Speichern ist durch den Einsatz eines Object-Document-Mappers (ODM) für Doctrine 2 und MongoDB\footnote{\url{https://github.com/doctrine/mongodb-odm}} weitestgehend automatisiert. Dieses Modell ist deutlich einfacher als das in Abschnitt \ref{l:domänenmodell} / S.\pageref{l:domänenmodell} vorgestellte Domänenmodell, da im Prototyp nur wenige, entscheidende Funktionen implementiert wurden.

